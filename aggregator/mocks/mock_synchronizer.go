// Code generated by mockery v2.39.0. DO NOT EDIT.

package mocks

import (
	context "context"

	common "github.com/ethereum/go-ethereum/common"

	mock "github.com/stretchr/testify/mock"

	synchronizer "github.com/0xPolygonHermez/zkevm-synchronizer-l1/synchronizer"
)

// SynchronizerInterfaceMock is an autogenerated mock type for the Synchronizer type
type SynchronizerInterfaceMock struct {
	mock.Mock
}

// GetL1BlockByNumber provides a mock function with given fields: ctx, blockNumber
func (_m *SynchronizerInterfaceMock) GetL1BlockByNumber(ctx context.Context, blockNumber uint64) (*synchronizer.L1Block, error) {
	ret := _m.Called(ctx, blockNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetL1BlockByNumber")
	}

	var r0 *synchronizer.L1Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64) (*synchronizer.L1Block, error)); ok {
		return rf(ctx, blockNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *synchronizer.L1Block); ok {
		r0 = rf(ctx, blockNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*synchronizer.L1Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, blockNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetL1InfoRootPerIndex provides a mock function with given fields: ctx, L1InfoTreeIndex
func (_m *SynchronizerInterfaceMock) GetL1InfoRootPerIndex(ctx context.Context, L1InfoTreeIndex uint32) (common.Hash, error) {
	ret := _m.Called(ctx, L1InfoTreeIndex)

	if len(ret) == 0 {
		panic("no return value specified for GetL1InfoRootPerIndex")
	}

	var r0 common.Hash
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32) (common.Hash, error)); ok {
		return rf(ctx, L1InfoTreeIndex)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint32) common.Hash); ok {
		r0 = rf(ctx, L1InfoTreeIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Hash)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, L1InfoTreeIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetL1InfoTreeLeaves provides a mock function with given fields: ctx, indexLeaves
func (_m *SynchronizerInterfaceMock) GetL1InfoTreeLeaves(ctx context.Context, indexLeaves []uint32) (map[uint32]synchronizer.L1InfoTreeLeaf, error) {
	ret := _m.Called(ctx, indexLeaves)

	if len(ret) == 0 {
		panic("no return value specified for GetL1InfoTreeLeaves")
	}

	var r0 map[uint32]synchronizer.L1InfoTreeLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []uint32) (map[uint32]synchronizer.L1InfoTreeLeaf, error)); ok {
		return rf(ctx, indexLeaves)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []uint32) map[uint32]synchronizer.L1InfoTreeLeaf); ok {
		r0 = rf(ctx, indexLeaves)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[uint32]synchronizer.L1InfoTreeLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []uint32) error); ok {
		r1 = rf(ctx, indexLeaves)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastL1Block provides a mock function with given fields: ctx
func (_m *SynchronizerInterfaceMock) GetLastL1Block(ctx context.Context) (*synchronizer.L1Block, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastL1Block")
	}

	var r0 *synchronizer.L1Block
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*synchronizer.L1Block, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *synchronizer.L1Block); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*synchronizer.L1Block)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLastestVirtualBatchNumber provides a mock function with given fields: ctx
func (_m *SynchronizerInterfaceMock) GetLastestVirtualBatchNumber(ctx context.Context) (uint64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLastestVirtualBatchNumber")
	}

	var r0 uint64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (uint64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) uint64); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLeafsByL1InfoRoot provides a mock function with given fields: ctx, l1InfoRoot
func (_m *SynchronizerInterfaceMock) GetLeafsByL1InfoRoot(ctx context.Context, l1InfoRoot common.Hash) ([]synchronizer.L1InfoTreeLeaf, error) {
	ret := _m.Called(ctx, l1InfoRoot)

	if len(ret) == 0 {
		panic("no return value specified for GetLeafsByL1InfoRoot")
	}

	var r0 []synchronizer.L1InfoTreeLeaf
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) ([]synchronizer.L1InfoTreeLeaf, error)); ok {
		return rf(ctx, l1InfoRoot)
	}
	if rf, ok := ret.Get(0).(func(context.Context, common.Hash) []synchronizer.L1InfoTreeLeaf); ok {
		r0 = rf(ctx, l1InfoRoot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]synchronizer.L1InfoTreeLeaf)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, common.Hash) error); ok {
		r1 = rf(ctx, l1InfoRoot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSequenceByBatchNumber provides a mock function with given fields: ctx, batchNumber
func (_m *SynchronizerInterfaceMock) GetSequenceByBatchNumber(ctx context.Context, batchNumber uint64) (*synchronizer.SequencedBatches, error) {
	ret := _m.Called(ctx, batchNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetSequenceByBatchNumber")
	}

	var r0 *synchronizer.SequencedBatches
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64) (*synchronizer.SequencedBatches, error)); ok {
		return rf(ctx, batchNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *synchronizer.SequencedBatches); ok {
		r0 = rf(ctx, batchNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*synchronizer.SequencedBatches)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, batchNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVirtualBatchByBatchNumber provides a mock function with given fields: ctx, batchNumber
func (_m *SynchronizerInterfaceMock) GetVirtualBatchByBatchNumber(ctx context.Context, batchNumber uint64) (*synchronizer.VirtualBatch, error) {
	ret := _m.Called(ctx, batchNumber)

	if len(ret) == 0 {
		panic("no return value specified for GetVirtualBatchByBatchNumber")
	}

	var r0 *synchronizer.VirtualBatch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint64) (*synchronizer.VirtualBatch, error)); ok {
		return rf(ctx, batchNumber)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint64) *synchronizer.VirtualBatch); ok {
		r0 = rf(ctx, batchNumber)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*synchronizer.VirtualBatch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint64) error); ok {
		r1 = rf(ctx, batchNumber)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsSynced provides a mock function with given fields:
func (_m *SynchronizerInterfaceMock) IsSynced() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsSynced")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// SetCallbackOnReorgDone provides a mock function with given fields: callback
func (_m *SynchronizerInterfaceMock) SetCallbackOnReorgDone(callback func(synchronizer.ReorgExecutionResult)) {
	_m.Called(callback)
}

// SetCallbackOnRollbackBatches provides a mock function with given fields: callback
func (_m *SynchronizerInterfaceMock) SetCallbackOnRollbackBatches(callback func(synchronizer.RollbackBatchesData)) {
	_m.Called(callback)
}

// Stop provides a mock function with given fields:
func (_m *SynchronizerInterfaceMock) Stop() {
	_m.Called()
}

// Sync provides a mock function with given fields: returnOnSync
func (_m *SynchronizerInterfaceMock) Sync(returnOnSync bool) error {
	ret := _m.Called(returnOnSync)

	if len(ret) == 0 {
		panic("no return value specified for Sync")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(bool) error); ok {
		r0 = rf(returnOnSync)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewSynchronizerInterfaceMock creates a new instance of SynchronizerInterfaceMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSynchronizerInterfaceMock(t interface {
	mock.TestingT
	Cleanup(func())
}) *SynchronizerInterfaceMock {
	mock := &SynchronizerInterfaceMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
